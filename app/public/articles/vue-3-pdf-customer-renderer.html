<h2>Writing a Custom Renderer - Vue.js 3</h2>
<p>Among many other cool features, Vue.js 3 is much more modular than Vue.js 3. The project is consists of <a href="https://github.com/vuejs/vue-next">many different packages</a>, making it even more flexible and customizable.</p>
<p>One of the more interesting architectural changes is the decoupled renderer and runtime. This makes it much easier to build custom renderers.</p>
<p>
  You can get the source code as it appears in this article <a href="https://github.com/lmiller1990/vue-pdf-renderer-demo/tree/article-final">here</a>.
</p>
<h2>What is a Custom Renderer?</h2>
<p>Vue consists of several &quot;systems&quot;. There is the reactivity system, it's custom component system, a virtual DOM, and several others. A renderer is what takes the output of the virtual DOM and <em>renders</em> it using some UI layer. <a href="https://github.com/vuejs/vue-next/tree/master/packages/runtime-dom">The DOM renderer</a> (the only one that ships with Vue) could be considered only official renderer, and as such, the reference renderer.</p>
<p>So, a custom renderer is renderer that targets anything other than the DOM.</p>
<p>The official DOM renderer can also be considered the best resource to learn to build a custom renderer - if you want to write one, you will become very well acquainted with it, since there are not many other resources on building a Vue 3 renderer.</p>
<h2>Existing Literature</h2>
<p>The main resources I used when preparing this post were:</p>
<ul>
<li><a href="https://github.com/ycmjason/vuminal">Vuminal</a>. A terminal renderer. It's source code is overly modular and kind of difficult to navigate, and I couldn't get it to do anything much more than the basic counter example in the README.</li>
<li><a href="https://github.com/Planning-nl/vugel">Vugel</a>, a WebGL renderer.</li>
<li><a href="https://github.com/vuejs/vue-next/tree/master/packages/runtime-dom">Vue 3 DOM Renderer source</a>. This was the most useful resource by far.</li>
<li><a href="https://react-pdf.org/">React PDF</a>. This is a custom PDF renderer for React. Not Vue, but the ideas apply, and the inspiration for this project.</li>
</ul>
<h2>What Are We Building?</h2>
<p>I decided to go with a <em>PDF renderer</em>. The goal is to take something like this:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">:styles</span>=<span class="hljs-string">&quot;{color: &#x27;red&#x27;}&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;color in colors&quot;</span> <span class="hljs-attr">:styles</span>=<span class="hljs-string">&quot;{color}&quot;</span>&gt;</span>
        {{ color }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Default<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">:styles</span>=<span class="hljs-string">&quot;{color: &#x27;yellow&#x27;}&quot;</span>&gt;</span>Yellow<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">colors</span>: [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>And get this:</p>
<p align="center">
<img src="https://raw.githubusercontent.com/lmiller1990/vue-pdf-renderer-demo/article/screenshots/SS-final.png" alt="">
</p>
<p>I will be using <a href="https://pdfkit.org/">PDFKit</a> to produce the PDF. This is just an <em>example</em> - a fully featured PDF Renderer would be much more complex.</p>
<p>Let's get started!</p>
<h2>Anatomy of a Custom Renderer</h2>
<p>The <a href="https://github.com/vuejs/vue-next/tree/master/packages/runtime-core">runtime-core</a> gives us a hint and how to create a custom renderer:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vue/runtime-core&#x27;</span>

<span class="hljs-keyword">const</span> { render, createApp } = createRenderer({
  patchProp,
  insert,
  remove,
  createElement,
  <span class="hljs-comment">// ...</span>
})
</code></pre>
<p><code>createRenderer</code> takes one argument, an object of options. These are called <em>node ops</em>, short for <em>node operations</em>. Operations Vue can perform on nodes. This basically means CRUD actions (create, read, update, delete) and a few more. A full list including types can be found <a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-dom/src/nodeOps.ts">in the Vue source code</a>. It's pretty important to understand what they all do. Here a list of all the node ops.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> nodeOps = {
  patchProp(...args): <span class="hljs-built_in">void</span>;
  forcePatchProp?(...args): <span class="hljs-built_in">boolean</span>;
  insert(...args): <span class="hljs-built_in">void</span>;
  remove(...args): <span class="hljs-built_in">void</span>;
  createElement(...args): HostElement;
  createText(...args): HostNode;
  createComment(...args): HostNode;
  setText(...args): <span class="hljs-built_in">void</span>;
  setElementText(...args): <span class="hljs-built_in">void</span>;
  parentNode(...args): HostElement | <span class="hljs-literal">null</span>;
  nextSibling(...args): HostNode | <span class="hljs-literal">null</span>;
  querySelector?(...args): HostElement | <span class="hljs-literal">null</span>;
  setScopeId?(...args): <span class="hljs-built_in">void</span>;
  cloneNode?(...args): HostNode;
  insertStaticContent?(...args): HostElement[];
}
</code></pre>
<p>We are only interested in a subset of node ops. The reason is our PDF renderer will be <em>static</em> - no dynamic, real time updates. For this reason we have little need for things like <code>querySelector</code> or <code>remove</code> - since nodes are not moving around or otherwise dynamically changing, we won't be needing these. We also don't need things like <code>createComment</code> - PDFs don't have comments.</p>
<p>To figure out which node ops we need to implement, I'll just start writing the renderer, and filling them out as they get called.</p>
<h2>Creating the Renderer</h2>
<p>Time to write some code. We start by calling <code>createRenderer</code>, and passing in the node ops. For now I am just going to <code>console.log</code> the relevant values to illustrate how and when the different operations are called.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { RendererOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFNode</span> </span>{
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> = (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10000</span>).toFixed(<span class="hljs-number">0</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params">fn: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">any</span> </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`no-op: <span class="hljs-subst">${fn}</span>`</span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeOps: RendererOptions&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt; = {
  <span class="hljs-attr">patchProp</span>: <span class="hljs-function">(<span class="hljs-params">el, key, prevVal, nextVal</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;patchProp&#x27;</span>, { el, key, prevVal, nextVal })
  },

  <span class="hljs-attr">insert</span>: <span class="hljs-function">(<span class="hljs-params">child, parent, anchor</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;insert&#x27;</span>, { parent, child })
  },

  <span class="hljs-attr">createElement</span>: (tag): <span class="hljs-function"><span class="hljs-params">any</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`createElement: <span class="hljs-subst">${tag}</span>`</span>)
  },

  <span class="hljs-attr">createText</span>: <span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`createText: <span class="hljs-subst">${text}</span>`</span>)
    <span class="hljs-keyword">return</span> text
  },

  <span class="hljs-attr">parentNode</span>: <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parentNode&#x27;</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  },

  <span class="hljs-attr">createComment</span>: <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`createComment <span class="hljs-subst">${text}</span>`</span>)
    <span class="hljs-keyword">return</span> text
  },

  <span class="hljs-attr">setText</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;setText&#x27;</span>),
  <span class="hljs-attr">setElementText</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;setElementText&#x27;</span>),
  <span class="hljs-attr">nextSibling</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;nextSibling&#x27;</span>),
  <span class="hljs-attr">querySelector</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;querySelector&#x27;</span>),
  <span class="hljs-attr">setScopeId</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;setScopeId&#x27;</span>), 
  <span class="hljs-attr">cloneNode</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;cloneNode&#x27;</span>),
  <span class="hljs-attr">insertStaticContent</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;insertStaticContent&#x27;</span>),
  <span class="hljs-attr">forcePatchProp</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;forcePatchProp&#x27;</span>),
  <span class="hljs-attr">remove</span>: <span class="hljs-function">() =&gt;</span> noop(<span class="hljs-string">&#x27;remove&#x27;</span>),
}
</code></pre>
<p>I declared the &quot;host node&quot; <em>and</em> &quot;host element&quot; by passing <code>&lt;any, any&gt;</code> as the first second generic parameters to the <code>createRenderer</code> function. In a DOM renderer, the host node is <code>Node</code> and the host element is <code>Element</code>. I am not differentiating between the two here, yet, but I will later on. I will also improve the type defintions later on.</p>
<p>I made all the node ops that are not be used for this simple example throw an error. I figured out which node ops I would need by experimentation.</p>
<p>Let's try it out!</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { 
  RendererOptions, 
  createRenderer, 
  defineComponent, 
  compile 
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-comment">// ... </span>

<span class="hljs-keyword">const</span> App = defineComponent({
  <span class="hljs-attr">render</span>: compile(<span class="hljs-string">`
    &lt;Text&gt;This is some text&lt;/Text&gt;
  `</span>)
})

<span class="hljs-keyword">const</span> root = {}

<span class="hljs-keyword">const</span> { createApp } = createRenderer(nodeOps)
<span class="hljs-keyword">const</span> app = createApp(App).mount(root)
</code></pre>
<p>This is the output:</p>
<pre class="hljs"><code>[Vue warn]: Failed to resolve component: Text
  at &lt;App&gt;
createElement: Text
createText: This is some text
insert { parent: undefined, child: 'This is some text' }

/Users/lachlan/code/dump/term-renderer/node_modules/@vue/runtime-core/dist/runtime-core.cjs.js:3805
            Object.defineProperty(el, '__vnode', {
                   ^
TypeError: Object.defineProperty called on non-object
</code></pre>
<p>We have not created a <code>&lt;Text&gt;</code> element yet, so we get a warning. Then three node ops are executed:</p>
<pre class="hljs"><code>createElement: Text
createText: This is some text
insert { parent: undefined, child: 'This is some text' }
</code></pre>
<p>Makes sense. Vue creates the <code>&lt;Text&gt;</code> element, then the inner text, then calls the <code>insert</code> node op to try and insert it. We then get an error that a <code>__vnode</code> property cannot be defined on an <code>el</code>.</p>
<h2>Defining Node Types</h2>
<p>The problem is our <code>createElement</code> and <code>createText</code> node ops are not returning any nodes - they should be creating and returning new nodes, as the names suggest.</p>
<p>We should make those node ops return the correct elements. I'll also improve the types.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFNode</span> </span>{
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> = (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10000</span>).toFixed(<span class="hljs-number">0</span>)
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFTextNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PDFNode</span> </span>{
  parent?: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-built_in">super</span>()
    <span class="hljs-built_in">this</span>.value = value
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PDFNode</span> </span>{}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFDocumentElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PDFElement</span> </span>{
  id = <span class="hljs-string">&#x27;root&#x27;</span>
  <span class="hljs-attr">children</span>: <span class="hljs-built_in">string</span>[] = []
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFTextElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PDFElement</span> </span>{
  parent?: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">children</span>: <span class="hljs-built_in">string</span>[] = []
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFViewElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PDFElement</span> </span>{
  parent?: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">children</span>: <span class="hljs-built_in">string</span>[] = []
}

<span class="hljs-keyword">type</span> PDFRenderable = PDFTextNode | PDFTextElement | PDFDocumentElement

<span class="hljs-keyword">type</span> PDFNodes = PDFTextNode
<span class="hljs-keyword">type</span> PDFElements = PDFTextElement | PDFDocumentElement | PDFViewElement

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeOps: RendererOptions&lt;PDFNodes, PDFElements&gt; = {
  <span class="hljs-comment">// ...</span>

  <span class="hljs-attr">createElement</span>: <span class="hljs-function">(<span class="hljs-params">tag: <span class="hljs-string">&#x27;Text&#x27;</span> | <span class="hljs-string">&#x27;Document&#x27;</span> | <span class="hljs-string">&#x27;View&#x27;</span></span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`createElement: <span class="hljs-subst">${tag}</span>`</span>)
    <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;Text&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PDFTextElement()
    }

    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unsupported tag <span class="hljs-subst">${tag}</span>`</span>)
  },

  <span class="hljs-attr">createText</span>: <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PDFTextNode(text)
  },

  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> { createApp } = createRenderer&lt;PDFTextNode, PDFElements&gt;(nodeOps)

<span class="hljs-keyword">const</span> App = defineComponent({
  <span class="hljs-attr">render</span>: compile(<span class="hljs-string">`
    &lt;Text&gt;This is some text&lt;/Text&gt;
  `</span>)
})

<span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> PDFDocumentElement()

<span class="hljs-keyword">const</span> { createApp } = createRenderer&lt;PDFNode, PDFElements&gt;(nodeOps)
<span class="hljs-keyword">const</span> app = createApp(App).mount(root)
</code></pre>
<p>Unlike a DOM renderer, where all the build in node types have already been defined by a the DOM specification, there is no such thing for PDFs. I decided to define my own node types to model a PDF.</p>
<p>I also added <code>parent</code> and <code>children</code> keys to some of the nodes and elements. You will see why soon.</p>
<p>Running this now works a whole lot better:</p>
<pre class="hljs"><code>[Vue warn]: Failed to resolve component: Text
  at &lt;App&gt;
createElement: Text
insert {
  parent: PDFTextElement { id: '831', children: [] },
  child: PDFTextNode { id: '9528', value: 'This is some text' }
}
insert {
  parent: PDFDocumentElement { id: '9992', children: [] },
  child: PDFTextElement { id: '831', children: [] }
}
</code></pre>
<p>This looks promising. The nodes are created and inserted (well, the <code>insert</code> node op is called) on the correct pair of nodes.</p>
<h2>Handling Insert</h2>
<p>We don't have any way to track the parent-child relationship between the nodes. Looking at the <a href="https://github.com/vuejs/vue-next/blob/07559e5dd7e392c415d098f75ab4dee03065302e/packages/runtime-dom/src/nodeOps.ts#L12">Vue DOM Renderer</a> we can see this is handled using <code>node.insertBefore</code>, which comes for free from the DOM. We will need something similar. This is because when it comes time to integrate PDFKit, we want to support styles in a cascading fashion. For example:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">:styles</span>=<span class="hljs-string">&quot;{color: &#x27;red&#x27;}&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Text<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
</code></pre>
<p>In this case, <code>Text</code> should be red - we need to know the parent, so we can recursively climb the tree to find the nearest parent node with a color attribute set. It will also be useful if we want to support something like the flex box model, where the child's layout depends on the parent.</p>
<p>Update <code>insert</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> nodeMap: Record&lt;<span class="hljs-built_in">string</span>, PDFNodes | PDFElements&gt; = {}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeOps: RendererOptions&lt;PDFNodes, PDFElements&gt; = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">insert</span>: <span class="hljs-function">(<span class="hljs-params">child, parent, anchor</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> PDFDocumentElement) {
      nodeMap[parent.id] = parent
    }

    <span class="hljs-keyword">if</span> (! (child.id <span class="hljs-keyword">in</span> nodeMap)) {
      nodeMap[child.id] = child
    }

    parent.children.push(child.id)
    child.parent = parent.id
  },

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>I added a few things:</p>
<ul>
<li><code>const nodeMap: Record&lt;string, PDFTextNode | PDFTextElement&gt; = {}</code>. This is to keep track of the nodes - it turns out it'll be useful to have our own cache of the nodes for later.</li>
<li><code>nodeMap['root']</code> to easily access the top level <code>PDFDocumentElement</code> node.</li>
<li>Assigning values to <code>parent</code> and <code>children</code>. I am keeping track of these by the <code>id</code>, not a reference to the actual node. We can easily get the node from the <code>nodeMap</code> when we need it.</li>
</ul>
<p><code>nodeMap</code> looks like this:</p>
<pre class="hljs"><code>{
  &#x27;325&#x27;: PDFTextNode { 
    id: &#x27;<span class="hljs-number">325</span>&#x27;, 
    value: &#x27;This is some text&#x27; 
  },
  &#x27;6805&#x27;: PDFTextElement { 
    id: &#x27;<span class="hljs-number">6805</span>&#x27;, 
    children: [ &#x27;<span class="hljs-number">325</span>&#x27; ] 
  },
  root: PDFDocumentElement { 
    id: &#x27;<span class="hljs-number">8306</span>&#x27;, 
    children: [ &#x27;<span class="hljs-number">6805</span>&#x27; ] 
  }
}
</code></pre>
<h2>Creating a Custom Tree Structure</h2>
<p>You may have noticed we are more or less extracting our own tree structure from the node ops as they are executed. An alternative would be to use Vue's own internal virtual DOM, which can be accessed like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { createApp } = createRenderer(nodeOps)
<span class="hljs-keyword">const</span> app = createApp(App)
app.mount(root).$.subTree <span class="hljs-comment">//=&gt; access virtual DOM</span>
</code></pre>
<p>It turns out this isn't too practical, primarily because Vue's virtual DOM is <em>much</em> more noisy and complex than what we need for this simple example. You could consider using that, though, and it would be required if you were building any kind of real-time renderer than relies on reactivity. In this example I am building a <em>static</em> renderer, so we don't have any need for reactivity or any of the other features Vue's virtual DOM supports.</p>
<p>For this reason I decided to create my own simple node cache (the <code>nodeMap</code> object) which is seeded by the initial virtual DOM render. We still get the power of Vue's directives, like <code>v-for</code> and v-if`, as well as the ability tocreate a PDF using Vue's declarative template system, as we will see soon!</p>
<h2>Custom Components</h2>
<p>The console still has the warnings about <code>&lt;Text&gt;</code> and <code>&lt;View&gt;</code> components not existing. Let's make those.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-comment">// ... </span>

<span class="hljs-keyword">const</span> createPDFComponent = <span class="hljs-function">(<span class="hljs-params">tag: <span class="hljs-built_in">string</span></span>) =&gt;</span> 
  defineComponent({
    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">name</span>: tag,
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">return</span> h(tag, <span class="hljs-built_in">this</span>.$attrs, <span class="hljs-built_in">this</span>.$slots?.default?.() || [])
    }
  })

<span class="hljs-keyword">const</span> View = createPDFComponent(<span class="hljs-string">&#x27;View&#x27;</span>)
<span class="hljs-keyword">const</span> Text = createPDFComponent(<span class="hljs-string">&#x27;Text&#x27;</span>)
<span class="hljs-keyword">const</span> Document = createPDFComponent(<span class="hljs-string">&#x27;Document&#x27;</span>)

<span class="hljs-keyword">const</span> App = defineComponent({
  <span class="hljs-attr">components</span>: { Text, View },
  <span class="hljs-attr">render</span>: compile(<span class="hljs-string">`
    &lt;Text&gt;This is some text&lt;/Text&gt;
  `</span>)
})
</code></pre>
<p>We are not really using Vue's component system heavily in this example, nor the the virtual DOM, so the components don't do a whole lot - basically just render their children and forward the attributes, like <code>styles</code>, which we will implement soon. I might like to add more complex, featureful components in the future though, so we should keep this in mind as we build.</p>
<h2>Rendering a PDF</h2>
<p>I am using <a href="https://pdfkit.org/">PDFKit</a> to produce the PDF. It has an imperative API. To draw some red text, you would write:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { PDFDocument } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pdfkit&#x27;</span>

<span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">new</span> PDFDocument()
pdf
.fill(<span class="hljs-string">&#x27;red&#x27;</span>)
.text(<span class="hljs-string">&#x27;This is some text&#x27;</span>)
</code></pre>
<p>This means we need to somehow go from the <code>nodeMap</code> to this. The first step will be to traverse the nodes, and the second step will be drawing and text or styles.</p>
<p>Let's start with a <code>traverse</code> function:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> draw = <span class="hljs-function">(<span class="hljs-params">node: PDFRenderable</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">node: PDFRenderable</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> PDFElement) {

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> node.children) {
      draw(nodeMap[child])
      traverse(nodeMap[child])
    }
  }
}
</code></pre>
<p><code>PDFRenderable</code> represents any node in our tree - both <code>PDFNodes</code> and the more complex <code>PDFElements</code>, which includes <code>PDFDocumentElement</code> and <code>PDFViewElement</code> at the moment.</p>
<p><code>PDFTextNode</code> never has children - but <code>PDFElement</code> does. If we are traversing a <code>PDFElement</code>, we want to traverse all of the children, too. <code>draw</code> will handle interfacing with PDFKit.</p>
<p>Now add <code>draw</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> draw = <span class="hljs-function">(<span class="hljs-params">node: PDFRenderable</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> PDFTextNode) {
    pdf.text(node.value)
  }
}
</code></pre>
<p>Finally, write the PDF to the filesystem using <code>fs</code></p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> PDFDocument <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pdfkit&#x27;</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>

<span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">new</span> PDFDocument()
<span class="hljs-keyword">const</span> stream = pdf.pipe(fs.createWriteStream(<span class="hljs-string">&#x27;./goal.pdf&#x27;</span>))

<span class="hljs-comment">// ... </span>

<span class="hljs-keyword">const</span> rootNode = nodeMap[<span class="hljs-string">&#x27;root&#x27;</span>]
traverse(rootNode)

pdf.end()
stream.on(<span class="hljs-string">&#x27;finish&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Wrote to file.pdf.&#x27;</span>)
})
</code></pre>
<p>Finally, we have a PDF!</p>
<p align="center">
<img src="https://raw.githubusercontent.com/lmiller1990/vue-pdf-renderer-demo/article/screenshots/SS-2.png" alt="">
</p>
<p>Now we get to have some fun and add <em>styles</em>.</p>
<h2>Adding Styles</h2>
<p>I have decided all styles should be defined in a <code>styles</code> attribute. I have decided to only support a limited subset of CSS, much like react-native and <a href="https://react-pdf.org/styling#valid-css-properties"><code>react-pdf</code></a>.</p>
<p>Update the example:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> App = defineComponent({
  <span class="hljs-attr">components</span>: { Text, View },
  <span class="hljs-attr">render</span>: compile(<span class="hljs-string">`
<span class="highlighted-line">    &lt;View :styles=&quot;{color: &#x27;red&#x27;}&quot;&gt;</span>      &lt;Text&gt;This is some text&lt;/Text&gt;
<span class="highlighted-line">    &lt;/View&gt;</span>  `</span>)
})
</code></pre>
<p>Also, update <code>createElement</code> to support <code>&lt;View&gt;</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeOps: RendererOptions&lt;PDFNodes, PDFElements&gt; = {
  <span class="hljs-comment">// ...</span>
<span class="highlighted-line">  <span class="hljs-attr">createElement</span>: <span class="hljs-function">(<span class="hljs-params">tag: <span class="hljs-string">&#x27;Text&#x27;</span> | <span class="hljs-string">&#x27;Document&#x27;</span> | <span class="hljs-string">&#x27;View&#x27;</span></span>) =&gt;</span> {</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`createElement: <span class="hljs-subst">${tag}</span>`</span>)
    <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;Text&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PDFTextElement()
    }

<span class="highlighted-line">    <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;View&#x27;</span>) {</span><span class="highlighted-line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PDFViewElement()</span><span class="highlighted-line">    }</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unknown tag <span class="hljs-subst">${tag}</span>`</span>)
  },
}
</code></pre>
<p>Running this shows the <code>patchProp</code> node op is now called!</p>
<pre class="hljs"><code>createElement: View
createElement: Text
insert {
  parent: PDFTextElement { id: <span class="hljs-string">&#x27;2358&#x27;</span>, children: [] },
  child: PDFTextNode { id: <span class="hljs-string">&#x27;9202&#x27;</span>, value: <span class="hljs-string">&#x27;This is some text&#x27;</span> }
}
insert {
  parent: PDFViewElement { id: <span class="hljs-string">&#x27;5973&#x27;</span>, children: [] },
  child: PDFTextElement { id: <span class="hljs-string">&#x27;2358&#x27;</span>, children: [ <span class="hljs-string">&#x27;9202&#x27;</span> ] }
}
<span class="highlighted-line">patchProp {</span><span class="highlighted-line">  el: PDFViewElement { id: <span class="hljs-string">&#x27;5973&#x27;</span>, children: [ <span class="hljs-string">&#x27;2358&#x27;</span> ] },</span><span class="highlighted-line">  key: <span class="hljs-string">&#x27;styles&#x27;</span>,</span><span class="highlighted-line">  prevVal: null,</span><span class="highlighted-line">  nextVal: { color: <span class="hljs-string">&#x27;red&#x27;</span> }</span><span class="highlighted-line">}</span>insert {
  parent: PDFDocumentElement { id: <span class="hljs-string">&#x27;7005&#x27;</span>, children: [] },
  child: PDFViewElement { id: <span class="hljs-string">&#x27;5973&#x27;</span>, children: [ <span class="hljs-string">&#x27;2358&#x27;</span> ] }
}
</code></pre>
<p><code>patchProp</code> applies updates to attributes - this can include <code>class</code>, <code>style</code>, or any other attribute, including custom attributes. We need to grab <code>styles</code> and store it somewhere. We want <code>key</code> and <code>nextVal</code> in this case. We also need to update <code>PDFElement</code> to have a <code>styles</code> property.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PDFNode</span> </span>{
<span class="highlighted-line">  <span class="hljs-attr">styles</span>: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = {}</span>}

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeOps: RendererOptions&lt;PDFNodes, PDFElements&gt; = {
  <span class="hljs-comment">// ...</span>

  <span class="hljs-attr">patchProp</span>: <span class="hljs-function">(<span class="hljs-params">el, key, prevVal, nextVal: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;</span>) =&gt;</span> {
<span class="highlighted-line">    <span class="hljs-keyword">if</span> (nextVal &amp;&amp; key === <span class="hljs-string">&#x27;styles&#x27;</span>) {</span><span class="highlighted-line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [attr, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(nextVal)) {</span><span class="highlighted-line">        el.styles[attr] = value</span><span class="highlighted-line">      }</span><span class="highlighted-line">    }</span>  },

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Now update <code>draw</code> to apply the style.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> draw = <span class="hljs-function">(<span class="hljs-params">node: PDFRenderable</span>) =&gt;</span> {
<span class="highlighted-line">  <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> PDFElement) {</span><span class="highlighted-line">    <span class="hljs-keyword">if</span> (node.styles.color) {</span><span class="highlighted-line">      pdf.fill(node.styles.color)</span><span class="highlighted-line">    }</span><span class="highlighted-line">  }</span>
  <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> PDFTextNode) {
    pdf.text(node.value)
  }
}
</code></pre>
<p>Now we have red text:</p>
<p align="center">
<img src="https://raw.githubusercontent.com/lmiller1990/vue-pdf-renderer-demo/article/screenshots/SS-3.png" alt="">
</p>
<h2>Supporting Default Styles</h2>
<p>We have cascading styles - anything nested under a <code>&lt;View&gt;</code> with <code>{color: 'red'}</code> will be red. The way PDFKit works is not exactly what we want, though - once you do <code>pdf.fill('red')</code>, everything will be red until you change the color to something else. What we want to do is mimic a browser - to figure out the correct color, we should recurse up the tree until we find a parent with <code>:styles=&quot;{color: '...'}&quot;</code>. If we don't, we should apply some default color. Black seems like the obvious choice.</p>
<p>This can be implememnted using a recursive <code>getParentStyle</code> function, and by setting some defaults:</p>
<pre class="language-ts"><code class="language-ts"><span class="highlighted-line"><pre class="hljs"><code><span class="hljs-keyword">const</span> defaults: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = {</span><span class="highlighted-line">  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;black&#x27;</span></span><span class="highlighted-line">}</span><span class="highlighted-line"></span><span class="highlighted-line"><span class="hljs-keyword">const</span> getParentStyle = (attr: <span class="hljs-built_in">string</span>, <span class="hljs-attr">parent</span>: PDFRenderable): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {</span><span class="highlighted-line">  <span class="hljs-comment">// we are at the root &lt;Document&gt; element.</span></span><span class="highlighted-line">  <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> PDFDocumentElement) {</span><span class="highlighted-line">    <span class="hljs-keyword">return</span> defaults[attr]</span><span class="highlighted-line">  }</span><span class="highlighted-line"></span><span class="highlighted-line">  <span class="hljs-comment">// check parent for style.</span></span><span class="highlighted-line">  <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> PDFElement) {</span><span class="highlighted-line">    <span class="hljs-keyword">if</span> (parent.styles[attr]) {</span><span class="highlighted-line">      <span class="hljs-keyword">return</span> parent.styles[attr]</span><span class="highlighted-line">    }</span><span class="highlighted-line">  }</span><span class="highlighted-line"></span><span class="highlighted-line">  <span class="hljs-comment">// recurse up the tree.</span></span><span class="highlighted-line">  <span class="hljs-keyword">return</span> getParentStyle(attr, nodeMap[parent.parent!])</span><span class="highlighted-line">}</span>
<span class="hljs-keyword">const</span> draw = <span class="hljs-function">(<span class="hljs-params">node: PDFRenderable</span>) =&gt;</span> {
<span class="highlighted-line">  <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> PDFElement) {</span><span class="highlighted-line">    <span class="hljs-keyword">if</span> (node.styles.color) {</span><span class="highlighted-line">      pdf.fill(node.styles.color)</span><span class="highlighted-line">    } <span class="hljs-keyword">else</span> {</span><span class="highlighted-line">      <span class="hljs-comment">// @ts-ignore</span></span><span class="highlighted-line">      pdf.fill(getParentStyle(<span class="hljs-string">&#x27;color&#x27;</span>, nodeMap[node.parent]))</span><span class="highlighted-line">    }</span><span class="highlighted-line">  }</span>
  <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> PDFTextNode) {
    pdf.text(node.value)
  }
}
</code></pre></code></pre><p>Let's make the example a bit more interesting. I will use <code>v-for</code>, to make sure everything works as it should:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> App = defineComponent({
  <span class="hljs-attr">components</span>: { Text, View },
<span class="highlighted-line">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> {</span><span class="highlighted-line">    <span class="hljs-keyword">return</span> {</span><span class="highlighted-line">      <span class="hljs-attr">colors</span>: [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]</span><span class="highlighted-line">    }</span><span class="highlighted-line">  },</span>  <span class="hljs-attr">render</span>: compile(<span class="hljs-string">`
<span class="highlighted-line">    &lt;View&gt;</span><span class="highlighted-line">      &lt;View :styles=&quot;{color: &#x27;red&#x27;}&quot;&gt;</span><span class="highlighted-line">        &lt;Text v-for=&quot;color in colors&quot; :styles=&quot;{color}&quot;&gt;</span><span class="highlighted-line">          {{ color }}</span><span class="highlighted-line">        &lt;/Text&gt;</span><span class="highlighted-line">      &lt;/View&gt;</span><span class="highlighted-line">      &lt;Text&gt;Default&lt;/Text&gt;</span><span class="highlighted-line">      &lt;Text :styles=&quot;{color: &#x27;yellow&#x27;}&quot;&gt;Yellow&lt;/Text&gt;</span><span class="highlighted-line">    &lt;/View&gt;</span><span class="highlighted-line">  `</span>)</span>})
</code></pre>
<p>It works:</p>
<p align="center">
<img src="https://raw.githubusercontent.com/lmiller1990/vue-pdf-renderer-demo/article/screenshots/SS-final.png" alt="">
</p>
<h2>Conclusion</h2>